package dev.lochert.ds.blockchain

import com.sun.net.httpserver.HttpExchange
import com.sun.net.httpserver.HttpHandler
import com.sun.net.httpserver.HttpServer
import dev.lochert.ds.blockchain.address.AddressList
import dev.lochert.ds.blockchain.block.Block
import dev.lochert.ds.blockchain.block.BlockChain
import dev.lochert.ds.blockchain.block.BlockProposal
import kotlinx.serialization.json.Json
import java.io.OutputStream
import java.net.InetSocketAddress

/**
 * Dummy Code generated by ChatGPT
 */
fun main(args: Array<String>) {
    val port = if (args.isNotEmpty()) args[0].toInt() else 8080
    val server = HttpServer.create(InetSocketAddress(port), 0)

    val addressList = AddressList()
    val blockChain = BlockChain(Block.genesisNode)

    // List all Addresses
    server.createContext("/address", AddrHandler(addressList, blockChain))


    // GET: /block -> Get all blocks
    // POST: /block -> Receive a block that should be added to the Blockchain
    //      201 - Created
    //      208 - Already Reported (i.e. Block has already been processed)
    //      400 - Invalid JSON
    //      406 - Not Acceptable - Parent Hash does not match
    server.createContext("/block", GetBlocksHandler(blockChain))
    // Get a specific block by hash or by index (genesis block is 0)
    server.createContext("/block/hash", BlockHandlerHash(addressList, blockChain))
    server.createContext("/block/index", BlockHandlerIndex(blockChain))

    // Send a node the instruction to add a block
    server.createContext("/control/add-block", ControlAddHandler(blockChain))



    server.executor = null
    server.start()
    println("Server started on port $port")
}


class AddrHandler(val addressList: AddressList, val blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        addressList.addAddress(exchange)
        val response = "$addressList"
        sendResponse(exchange, response)
    }
}

class GetBlocksHandler(val blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = Json.encodeToString(blockChain.listOfBlocks)
        sendResponse(exchange, response)
    }
}

class GetDataHandler(addressList: AddressList, blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /getdata"
        sendResponse(exchange, response)
    }
}


class BlockHandlerHash(addressList: AddressList, blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /block"
        sendResponse(exchange, response)
    }
}
class BlockHandlerIndex(val blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val path = exchange.requestURI.path  // Get request path
        val parts = path.split("/")          // Split path into segments

        if (parts.size < 4) {
            sendResponse(exchange, "Invalid request", 400)
            return
        }

        val indexStr = parts[3] // Extract index from path
        val index = indexStr.toIntOrNull() // Convert to integer safely

        if (index == null || index !in blockChain.listOfBlocks.indices) {
            sendResponse(exchange, "Block not found", 404)
            return
        }

        val response = Json.encodeToString(blockChain.listOfBlocks[index])
        sendResponse(exchange, response, 200)
    }
}
class ControlAddHandler(val blockChain: BlockChain) : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val path = exchange.requestURI.path  // Get the request path
        val parts = path.split("/")          // Split into segments

        if (parts.size < 4) {  // Expecting /control/addblock/{string}
            sendResponse(exchange, "Invalid request format", 400)
            return
        }

        val content = parts[3] // Extract the string from the path

        println("Received content: $content") // Print it out
        val block = blockChain.addBlock(content)

        sendResponse(exchange, Json.encodeToString(block.blockHash), 200)
    }
}


fun sendResponse(exchange: HttpExchange, response: String, code:Int=200) {
    exchange.sendResponseHeaders(code, response.toByteArray().size.toLong())
    val os: OutputStream = exchange.responseBody
    os.write(response.toByteArray())
    os.close()
}
