package dev.lochert.ds.blockchain

import com.sun.net.httpserver.HttpExchange
import com.sun.net.httpserver.HttpHandler
import com.sun.net.httpserver.HttpServer
import java.io.OutputStream
import java.net.InetSocketAddress

/**
 * Dummy Code generated by ChatGPT
 */
fun main(args: Array<String>) {
    val port = if (args.isNotEmpty()) args[0].toInt() else 8080
    val server = HttpServer.create(InetSocketAddress(port), 0)

    server.createContext("/addresses", AddrHandler())
    server.createContext("/getblocks", GetBlocksHandler())
    server.createContext("/getdata", GetDataHandler())
    server.createContext("/inv", InvHandler())
    server.createContext("/block", BlockHandler())
    server.createContext("/control/addblock", ControlHandler())
    server.createContext("/control/populate", ControlHandler())

    server.executor = null
    server.start()
    println("Server started on port $port")
}

class ControlHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "TODO"
        sendResponse(exchange, response)
    }
}

class AddrHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /addr"
        sendResponse(exchange, response)
    }
}

class GetBlocksHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /getblocks"
        sendResponse(exchange, response)
    }
}

class GetDataHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /getdata"
        sendResponse(exchange, response)
    }
}

class InvHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /inv"
        sendResponse(exchange, response)
    }
}

class BlockHandler : HttpHandler {
    override fun handle(exchange: HttpExchange) {
        val response = "Dummy response for /block"
        sendResponse(exchange, response)
    }
}

fun sendResponse(exchange: HttpExchange, response: String) {
    exchange.sendResponseHeaders(200, response.toByteArray().size.toLong())
    val os: OutputStream = exchange.responseBody
    os.write(response.toByteArray())
    os.close()
}
